---
output:
  github_document
---

DNA methylation analysis with Illumina's Infinium DNA methylation probes  
========================================================

Contributors: Gloria Li, Jasleen Grewal, and Keegan Korthauer

> This seminar is inspired by a STAT 540 project in 2013: *Analysis of Gene Expression Omnibus Leukemia Data from the Illumina HumanMethylation450 Array* by Alice Zhu, Rachel Edgar, Shaun Jackman and Nick Fishbane. See their project website [here](https://sites.google.com/site/stat540diffmethleuk/).   

## Learning objectives   

By the end of this tutorial, you should be able to  
- Identify the basic steps in a methylation analysis pipeline  
- Appreciate the role of normalization prior to analysis in methylation datasets, and know what M values are  
- Undertake exploratory visual analysis of methylation data (plotting Beta value densities)  
- Undertake differential methylation analysis and annotate CpG island probes for interpretation  
- Plot results from differential analysis (differentially methylated probes) across all chromosomes, to highlight areas under regulatory influence as per the methylation profiles  

## Setup

First we load necessary packages into our session. If any of these packages are not already installed on your system, you'll first need to install them with `BiocManager::install()`.

```{r, message=FALSE, warning=FALSE}
library(SummarizedExperiment)
library(ggplot2)
theme_set(theme_bw())
library(GEOquery)
library(limma)
library(FDb.InfiniumMethylation.hg19)
library(tidyverse)
library(ComplexHeatmap)
library(circlize)
library(wateRmelon)
```

## Introduction  

The Illumina Infiniumn Array is a microarray-based high throughput platform for methylation profiling on 487,173 pre-selected probes for CpGs across the human genome. This platform is an aggregation of the Illumina HumanMethylation27 ("27K") and HumanMethylation450 ("450K") arrays. A great number of these datasets have been made publicly available through Gene Expression Omnibus (GEO). Each dataset in GEO has a unique GSE ID that we can use to retrieve it from GEO, with the help of packages like `GEOquery` which we loaded above. 

## Explore 450K methylation array data

In this seminar, we are going to perform differential methylation analysis for Acute lymphoblastic leukemia (ALL) cases and healthy B cells as control group. The datasets we are going to use are: [GSE39141](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE39141) which contains 29 ALL bone marrow samples and 4 healthy B cell samples, and to make up for the small sample size for healthy cells,  we will also use [GSE42865](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE42865) which contains 9 healthy B cell samples and 7 samples with other conditions.    

First, let's retrieve our datasets from GEO with `getGEO` from `GEOquery` package.

**NOTE:** Due to many factors (like server load, your internet connection, and more) downloading large datasets from GEO may take a some time. Pre-formatted versions of the data has been made available as .rds files via a [Dropbox share](https://www.dropbox.com/sh/s2ut2bu8ahuxumn/AAAazmOgfCD5EDyUxqVIVW9-a?dl=0).  If you experience delays downloading direct from GEO, try downloading these two .RData files instead by changing the following code chunk to `eval = TRUE`. Note that these are still moderately large files (115 MB and 33 MB), so will only noticeably save time if the GEO server is experiencing a high load.

```{r, eval = FALSE}
# option to download pre-formatted data from Dropbox 
# (if you experience issues downloading directly from GEO)
download.file("https://www.dropbox.com/s/11fprv8ayksd91u/methyl_ALL.rds?dl=1",
              destfile = "methyl_ALL.rds")
download.file("https://www.dropbox.com/s/hyii130s996w2vc/methyl_CTRL.rds?dl=1",
              destfile = "methyl_CTRL.rds")
```


```{r fetchGEO, message = FALSE}
if(file.exists("methyl_ALL.rds") & file.exists("methyl_CTRL.rds")){ # if previously downloaded
  ALL <- readRDS("methyl_ALL.rds")
  CTRL <- readRDS("methyl_CTRL.rds")
} else { # if downloading for the first time
  GSE39141 <- getGEO('GSE39141', getGPL = FALSE)[[1]]
  show(GSE39141) ## 33 samples (29 ALL and 4 healthy B cells)
  GSE42865 <- getGEO('GSE42865', getGPL = FALSE)[[1]]
  show(GSE42865) ## 16 samples (9 healthy cells B cells and 7 other cells)
  
  # convert to summarized experiment objects
  ALL <- makeSummarizedExperimentFromExpressionSet(GSE39141)
  CTRL <- makeSummarizedExperimentFromExpressionSet(GSE42865)
  
  # rename assays slot to an informative name (we have beta values)
  names(assays(ALL)) <- "beta"
  names(assays(CTRL)) <- "beta"
  
    # Subset CTRL for control (healthy) donors   
  CTRL <- CTRL[, grepl("Healthy donor", colData(CTRL)$characteristics_ch1.1)]
  
  # create simpler data labels
  # ALL: Case; HBC: Healthy B Cells
  colData(ALL)$Group <- ifelse(colData(ALL)$disease.state.ch1 == "leukemia", 
                                    "ALL", "HBC")
  colData(CTRL)$Group <- "HBC"

  # save the RData objects so they doesn't need to be re downloaded each time
  saveRDS(ALL, file = "methyl_ALL.rds")
  saveRDS(CTRL, file = "methyl_CTRL.rds")
}
```

As you can see, the datasets we got are `ExpressionSet` objects including Beta values as well as metadata. We first convert `ExpressionSet` objects into `SummarizedExperiment` objects (so that we can have multiple assays slots, which will be handy when we compute normalized beta values and M-values). Then we can subset the GSE42865 object to contain only the healthy cells. Finally, we create a Group variable that indicates whether the sample is ALL or HBC (healthy B cell). And then we save the two objects into one RData file that can be used in later sessions (without the need to re-download the data).

Now, we can do some exploratory analysis of the data, for examples, looking at distribution of Beta values in each sample or each probe. Here is a density plot of average Beta values for probes in the two datasets. 

> Note: you can use `rowMeans` function to calculate the average Beta value for each probe. Don't forget to use `na.rm = TRUE` to exclude NAs.

```{r exploratory, echo = T}
# density plot
plotDat <- data.frame(Beta = c(rowMeans(assays(ALL[,colData(ALL)$Group == "ALL"])$beta, 
                                        na.rm = TRUE), 
                               rowMeans(assays(ALL[,colData(ALL)$Group == "HBC"])$beta, 
                                        na.rm = TRUE),
                               rowMeans(assays(CTRL)$beta, 
                                        na.rm = TRUE)),
                      Dataset = rep(c('GSE39141:ALL', 'GSE39141:HBC', 'GSE42865:HBC'), 
                                    each = nrow(ALL)))
probeAvg <- ggplot(data = plotDat, aes(x = Beta, col = Dataset)) +
   geom_density() + 
   ggtitle("Average Beta value density of two experiments") + 
   xlab("Beta") + 
   ylab("Density")
probeAvg
```

Here's also a sample-sample correlation heatmap.

```{r}
cc <- as.matrix(data.frame(cor(cbind(assays(ALL)$beta, assays(CTRL)$beta), 
                     use = "pairwise.complete.obs"), 
                     row.names = c(colnames(ALL), colnames(CTRL))))

annot <- HeatmapAnnotation(df = data.frame(Group = c(colData(ALL)$Group, 
                                                     colData(CTRL)$Group),
                                           Expmt = c(rep("GSE39141", ncol(ALL)),
                                                     rep("GSE42865", ncol(CTRL)))),
                           col = list(Group = c("ALL" =  "red", "HBC" = "blue"),
                                      Expmt = c("GSE39141" = "black", "GSE42865" = "grey")))

bcols <- colorRamp2(c(0.75, 0.875, 1), c("#000000", "#FF8000", "#FFFFFF"))

Heatmap(cc, col = bcols, name = "Corr",
        column_title = "Correlation of raw beta values",
        cluster_rows = FALSE, cluster_columns = FALSE, 
        top_annotation = annot, 
        row_names_gp = gpar(fontsize = 8), 
        column_names_gp = gpar(fontsize = 8))
```

## Data Normalization

You can see the distribution of Beta values are not the same between different experiments, or between the ALL and HBC groups within the same experiment. The difference between HBC groups between experiments illustrates why it is important to normalize the data before proceeding. A note of caution here - since we can't be sure the differences between ALL and HBC within experiment are due to technical factors (as opposed to biological differences), it is not appropriate to perform between-sample normalization that assumes the distribution of beta values is the same across all samples (such as quantile normalization, e.g. using `normalizeBetweenArrays` method from our trusted friend `limma`). If we did quantile normalize across all arrays, this could potentially remove biological signal. 

Instead, we may use intra-sample normalization approaches. Many normalization approaches for methylation microarray data (e.g. in the `minfi` package) operate on the raw intensity data to correct for background signal. We do not have such data, as we only have the beta values. However, there are others that operate on beta values, such as [BMIQ: Beta-Mixture Quantile (BMIQ) Normalisation method](https://pubmed.ncbi.nlm.nih.gov/23175756/), available in the Bioconductor package `wateRmelon`. This method aims to correct the bias of type II probes (which have a lower dynamic range than type I probes).

![](https://image.slidesharecdn.com/databasics-150730020758-lva1-app6891/95/data-basics-7-638.jpg?cb=1446133797)

Note that `wateRmelon` also offers several other methods for 450K methylation array normalization (mostly on raw intensity values). If you are interested in comparing these methods, check out [this paper](http://www.biomedcentral.com/1471-2164/14/293).

Here we apply BMIQ normalization on our beta values. Note that this step may take a few minutes to run. Ideally, we'd increase the `nfit` parameter (number of probes to use to estimate bias) to get a more robust fitting, but in the interest of time we set it to 100. We also set a seed since the probes for fitting are chosen randomly.

```{r normalization}
#First get annotation data from FDb database  
InfiniumMethylation <- getPlatform(platform = 'HM450', genome = 'hg19')
InfiniumMethylation <- InfiniumMethylation[sort(names(InfiniumMethylation)),]
show(InfiniumMethylation)

# check that probe information matches order of probes in dataset
identical(names(InfiniumMethylation), rownames(ALL))

# if probe has both channels, is Type II (72%). Otherwise Type I.
probeDesign <- ifelse(InfiniumMethylation$channel == "Both", "2", "1")
table(probeDesign)/length(probeDesign)

# run BMIQ
assays(ALL)$beta.norm <- apply(assays(ALL)$beta, 2, function(x){
  set.seed(29)
  BMIQ(x, probeDesign, nfit = 5000, 
       plots = FALSE, pri = FALSE)$nbeta
})

assays(CTRL)$beta.norm <- apply(assays(CTRL)$beta, 2, function(x){
  set.seed(29)
  BMIQ(x, probeDesign, nfit = 5000, 
       plots = FALSE, pri = FALSE)$nbeta
})
```
Now let's see how the distribution looks after intra-sample normalization.

```{r postNorm, echo = T}
plotDat <-
  rbind(
    data.frame(plotDat, Norm = "Before"),
    data.frame(Beta = c(rowMeans(assays(ALL[,colData(ALL)$Group == "ALL"])$beta.norm, 
                                        na.rm = TRUE), 
                        rowMeans(assays(ALL[,colData(ALL)$Group == "HBC"])$beta.norm, 
                                        na.rm = TRUE),
                        rowMeans(assays(CTRL)$beta.norm, 
                                        na.rm = TRUE)),
               Dataset = rep(c('GSE39141:ALL', 'GSE39141:HBC', 'GSE42865:HBC'), 
                             each = nrow(ALL)),
               Norm = "After")
  )

plotDat$Norm <- factor(plotDat$Norm, levels = c("Before", "After"))
probeAvgNorm <- ggplot(data = plotDat, aes(x = Beta, col = Dataset)) +
   geom_density() + 
   facet_grid(Norm ~ .) + 
   ggtitle("Density of Beta values before and after normalization") + 
   xlab("Beta") + 
   ylab("Density") 
probeAvgNorm
```
As you can see, after normalization, beta values from the different experiments have more similar distributions. Note that we did not do any between-sample normalization here, so we didn't assume anything about different samples being similar. We only removed bias of Type II probes. 

And here is the sample-sample correlation plot of the normalized beta values.

```{r}
cc.norm <- as.matrix(data.frame(cor(cbind(assays(ALL)$beta.norm, assays(CTRL)$beta.norm), 
                     use = "pairwise.complete.obs"), 
                     row.names = c(colnames(ALL), colnames(CTRL))))

Heatmap(cc.norm, col = bcols, name = "Corr",
        column_title = "Correlation of BMIQ normalized beta values",
        cluster_rows = FALSE, cluster_columns = FALSE, 
        top_annotation = annot, 
        row_names_gp = gpar(fontsize = 8), 
        column_names_gp = gpar(fontsize = 8))
```

We see that the sample-sample correlations have not appreciably changed.

## M values

Note that beta values live in the interval [0, 1], with two modes near the two extremes. This type of distribution is not very compatible with the typical assumptions of linear models. A common solution is to apply a **logit** transformation on the data to convert it to a continuous variable that spans $(-\infty, \infty)$, i.e. compute the M value.

$$M = log\Big({Beta \over 1-Beta}\Big)$$
Here we also regularize beta values that are very very close to zero or 1 (within 1e-6).

```{r Beta2M}
# regularize beta.norm within 0.001 of 0 or 1
assays(ALL)$beta.norm <- pmin(pmax(assays(ALL)$beta.norm, 1e-6), 1-1e-6)
assays(CTRL)$beta.norm <- pmin(pmax(assays(CTRL)$beta.norm, 1e-6), 1-1e-6)

assays(ALL)$m.norm <- log2(assays(ALL)$beta.norm/(1 - assays(ALL)$beta.norm))
assays(CTRL)$m.norm <- log2(assays(CTRL)$beta.norm/(1 - assays(CTRL)$beta.norm))
```

Before going further, we'll also remove probes with very little variation across samples.

```{r}
rmv <- which(rowVars(cbind(assays(ALL)$m.norm, assays(CTRL)$m.norm), na.rm = TRUE) < 0.25)
names(rmv) <- rownames(ALL)[rmv]
length(rmv)

ALL <- ALL[-rmv, ]
CTRL <- CTRL[-rmv, ]

InfiniumMethylation <- InfiniumMethylation[-which(names(InfiniumMethylation) %in% names(rmv)),]
```

## CpG Islands

Now we can go ahead with differential methylation analysis -- `cases vs. controls` or `leukemia vs. healthy`. You can perform this analysis on each probe, but in this seminar, we will aggregate the probes into CpG Islands (CGIs), i.e. the CpG dense regions of the genome, and then detect differentially methylated CGIs. The biological function of CGIs is better studied, so the interpretation of our results will be easier if we focus on CGIs.  

Conveniently, the Bioconductor package `FDb.InfiniumMethylation.hg19` provides all sorts of annotation information for the 450K methylation array including the association of probes to CGIs. Note that we already extracted some of this information when fetching the probe type info above (into `InfiniumMethylation`). Here we'll fetch even more annotation - CGI status, and use the *mean of M values* for all probes in a specific CGI to represent its methylation level. Check if you get the same boxplot for CGI M values.    

```{r eval=TRUE,echo=TRUE}
data(hg19.islands)

CGI.probes <- subsetByOverlaps(InfiniumMethylation, hg19.islands)
overlaps <- findOverlaps(InfiniumMethylation, hg19.islands)
CGI.probes$CGI <- hg19.islands$ID[overlaps@to]

CGI.probes
```

We can see that `r length(CGI.probes)` probes are in a total of `r length(unique(CGI.probes$CGI))`CGIs. Now we'll subset our data to just those probes in these CGIs, and then compute mean M-values over all probes in each CGI.

```{r aggregate}
ALL <- ALL[names(CGI.probes),]
CTRL <- CTRL[names(CGI.probes),]

CGI.probes$probe <- names(CGI.probes)
CGI.probes <- as.data.frame(CGI.probes)

m <- data.frame(Sample = c(colnames(ALL), colnames(CTRL)), 
                Group = c(colData(ALL)$Group, colData(CTRL)$Group))

cgi.mean.Mvalue <- cbind(assays(ALL)$m.norm, assays(CTRL)$m.norm) %>% 
  data.frame() %>%
  mutate(probe = rownames(ALL)) %>%
  pivot_longer(cols = -probe, names_to = "Sample", values_to = "m") %>%
  left_join(CGI.probes, by = "probe") %>%
  group_by(CGI, Sample) %>%
  summarize(mean_mval = mean(m, na.rm = TRUE)) %>%
  left_join(m, by = "Sample") 
```

Finally, we'll create a box plot of Mean CGI values per sample.

```{r M.CGI.boxplot, echo=T, warning=F}
# check the distribution of CGI M values with boxplot
cgi.mean.Mvalue %>%
  ggplot(aes(Sample, mean_mval, fill = Group)) + 
     geom_boxplot() + 
     ggtitle("Distribution of mean CGI M values") + 
     xlab("Samples") + 
     ylab("mean M values") + 
     theme_bw() + 
     scale_x_discrete(labels = NULL)
```

## Differential methylation analysis with limma

Next, we can use a linear model to identify differentially methylated CGIs with `limma`. You are already familiar with this part.    

```{r limma}
cgi.mean.Mvalue.mat <- cgi.mean.Mvalue %>%
  pivot_wider(id_cols = c(Sample, CGI),
              names_from = Sample,  values_from = mean_mval) %>%
  column_to_rownames(var = "CGI")

cgi.mean.Mvalue.mat <- cgi.mean.Mvalue.mat[, m$Sample]

identical(colnames(cgi.mean.Mvalue.mat), m$Sample)

DMRfit <- lmFit(cgi.mean.Mvalue.mat, model.matrix( ~ Group, data = m))
DMRfitEb <- eBayes(DMRfit)
cutoff <- 0.01
DMR <- topTable(DMRfitEb, coef = 'GroupHBC', number = Inf, p.value = cutoff)
head(DMR)   # top hits 
```

So using a cutoff of FDR = `r cutoff`, we identified `r nrow(DMR)` CGIs that are differentially methylated between ALL and control group. Now we can make some plots to check these hits. 

First, let us plot a heatmap of beta values of top 100 hits.    

```{r heatmap, message=F, warning=F} 

DMR100 <- topTable(DMRfitEb, coef = 'GroupHBC', number = 100)
DMR.CGI <- cgi.mean.Mvalue.mat[rownames(cgi.mean.Mvalue.mat) %in% rownames(DMR100),]
  
annot <- HeatmapAnnotation(df = data.frame(Group = c(colData(ALL)$Group, 
                                                     colData(CTRL)$Group),
                                           Expmt = c(rep("GSE39141", ncol(ALL)),
                                                     rep("GSE42865", ncol(CTRL)))),
                           col = list(Group = c("ALL" =  "red", "HBC" = "blue"),
                                      Expmt = c("GSE39141" = "black", "GSE42865" = "grey")))

ccols <- colorRampPalette(c("#000000" ,"#800000" ,"#FF8000" ,"#FFFF00", "#FFFFFF"))(20)

Heatmap(2^DMR.CGI / (1+2^DMR.CGI),  name = "beta",
        column_title = "Top 100 Differentially Methylated CGIs",
        cluster_rows = TRUE, cluster_columns = TRUE, 
        top_annotation = annot, 
        row_names_gp = gpar(fontsize = 8), 
        column_names_gp = gpar(fontsize = 8))
```

Next, stripplot of beta values of probes within top 5 CGI hits.   

```{r stripplot, warning=F, message=F, eval=T, echo = T}
DMR5 <- topTable(DMRfitEb, coef = 'GroupHBC', number = 5)
DMR.CGI <- cgi.mean.Mvalue.mat[rownames(DMR5),] %>%
  rownames_to_column(var = "CGI") %>%
  pivot_longer(cols = -CGI, names_to = c("Sample"), values_to = "M") %>%
  left_join(m, by = "Sample") %>%
  mutate(beta = 2^M / (1+2^M))

DMR.CGI %>%
   ggplot(aes(x = Group, y = beta, color = Group)) + 
   geom_point(position = position_jitter(width = 0.05), na.rm = T) + 
   stat_summary(fun = mean, aes(group = 1), geom = "line", color = "black") + 
   facet_grid(. ~ CGI) + 
   ggtitle("Probe beta values within top 5 DM CGIs") + 
   xlab("Group") + 
   ylab("beta") 
```

Finally, plot location of differentially methylated probes along each chromosome.   

```{r coord, warning=F, message=F, eval = FALSE}
chrlen = as.data.frame(seqinfo.hg19)
chrlen$chr = as.character(rownames(chrlen))
chrlen = chrlen[chrlen$chr %in% c("chrX",paste("chr",1:22,sep="")),]
chr <- probes_450k[,c("seqnames","start","Probe_ID")]; colnames(chr) = c("chr","coord","Probe_ID")
coord_big = merge(chr, chrlen, by="chr"); rownames(coord_big) = coord_big$Probe_ID
coord = coord_big[,c("chr","coord")]
# coordinates of probes in DM CGIs
coordDMRprobe <- droplevels(na.omit(coord[cginame[cginame$cginame %in% rownames(DMR),]$Probe_ID,])) 
coordDMRprobe$chr <- as.character(coordDMRprobe$chr)
ggplot(data = coordDMRprobe) + 
   geom_linerange(aes(x=chr, ymin = 0, ymax = seqlengths), data = chrlen, alpha = 0.5) + 
   geom_point(aes(x = chr, y = coord),
              position = position_jitter(width = 0.03), na.rm = T) + 
   ggtitle("DMR positions on chromosomes") + 
   ylab("Position of DMRs") +
   xlab("chr") +
   coord_flip() + 
   theme_bw()
```


## Interpretation and functional enrichment analysis

The next step in the analysis pipeline would be to interpret our result by associating these differentially methylated regions (DMRs) with biological features. DNA methylation in different genomic regions, i.e. promoter regions, enhancers, gene body etc., has different impact on gene transcription. A common practice in DMR analysis is to separate DMRs associated with different types of genomic regions and study them separately. Our key interest is to see how these DMRs affect gene expression level and consequently biological function.   
For that purpose, after we separate DMRs into different genomic regions, we will associate them with genes and then biological functions. There are many ways to do this. The `FDb.InfiniumMethylation.hg19` package itself contains some annotation information, including associating probes with different types of genomic regions and gene IDs. You can obtain this information similarly to how we extracted chromosome coordinates above. Here is a full list of all objects available in this package. Their names are self-explanatory, but if want more detailed description, check the [package manual document](http://www.bioconductor.org/packages/release/data/annotation/manuals/FDb.InfiniumMethylation.hg19/man/FDb.InfiniumMethylation.hg19.pdf).  

```{r} 
ls("package:FDb.InfiniumMethylation.hg19")
```              

There are a lot of resources that provide association between genes and biological function. Gene Ontology (GO) is a popular database that provides a controlled vocabulary of terms for describing gene product characteristics and functions including molecular function, biological process and cellular component. Also, there are databases like KEGG and PANTHER that provide association of genes with pathways for pathway analysis, and InterPro and Pfam etc. that provide protein domain analysis. You might have noticed from the list above that `FDb.InfiniumMethylation.hg19` also provides some of these association analyses like GO, but you would have more control and flexibility if you use other tools more specialized for functional enrichment analysis. There are two online tools that I found very helpful, both extremely easy to use. [DAVID](http://david.abcc.ncifcrf.gov/tools.jsp) takes a list of genes and outputs annotation and enrichment analysis from all sorts of databases including all the ones we discussed above. The results are available for downloading in tab delimited text format. Another more recent tool is [GREAT](http://bejerano.stanford.edu/great/public/html/). It was originally developed to associate regulatory regions with genes and biological functions and the required input is a list of coordinates. It also performs functional enrichment analysis from different databases and it can make some fancy plots for output.       

The interpretation of differential methylation analysis results is a very flexible and most often context-specific process. Functional enrichment analysis is just one popular way to approach this but there is really no *gold-standard pipeline* we can follow. Although we won't be able to go into it in this seminar, you should understand that identifying DMRs is really the easy part and digging up the biology behind it and make a story of it would be something you need to spend a lot of time considering.         

## Takehome assignment   

> Using plots generated above (or via) the above analysis, describe how and which linear modelling assumptions are imperfectly satisfied. If assumptions are violated, how does this affect the usage of Limma?
 
## Additional Notes    

The methylKit [package](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3491415/) makes the basic methylation analysis pipelines accessible to beginners. You can use this package to do hierarchical clustering analysis, identifying regions of hypo/hyper methylation, extract and visualize differential methylation events, and annotate CpG islands/custom regions.  
